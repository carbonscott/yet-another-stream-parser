# CrystFEL Stream File Format Documentation

This document describes the CrystFEL stream file format based on analysis of `stream.c` and `stream.h` from CrystFEL's libcrystfel library.

## Overview

The CrystFEL stream file is a **line-based text format** containing crystallographic indexing results. It stores:
- Detector geometry configuration
- Target unit cell parameters
- Per-image metadata, peaks, and indexed crystal information

## File Structure

```
CrystFEL stream format 2.3
Generated by CrystFEL X.X.X
[Command line arguments]
----- Begin geometry file -----
[Detector geometry configuration]
----- End geometry file -----
----- Begin unit cell -----
[Target unit cell parameters]
----- End unit cell -----
Indexing methods selected: [indexers]

----- Begin chunk -----
[Image/chunk data]
----- End chunk -----
[Additional chunks...]
```

## Section Markers

| Marker | Purpose |
|--------|---------|
| `----- Begin geometry file -----` | Start of detector geometry |
| `----- End geometry file -----` | End of detector geometry |
| `----- Begin unit cell -----` | Start of target unit cell |
| `----- End unit cell -----` | End of target unit cell |
| `----- Begin chunk -----` | Start of image/frame data |
| `----- End chunk -----` | End of image/frame data |
| `Peaks from peak search` | Start of peak list |
| `End of peak list` | End of peak list |
| `--- Begin crystal` | Start of crystal data |
| `--- End crystal` | End of crystal data |
| `Reflections measured after indexing` | Start of reflection list |
| `End of reflections` | End of reflection list |

## Chunk Structure

Each chunk represents one image/frame and contains:

### Chunk Metadata

```
Image filename: /path/to/data.h5
Event: //13
Image serial number: 42
hit = 1
indexed_by = mosflm-latt-nocell
n_indexing_tries = 1
photon_energy_eV = 9500.0
beam_divergence = 1.0e-03 rad
beam_bandwidth = 1.0e-04 (fraction)
average_camera_length = 0.150 m
```

| Field | Description | Units |
|-------|-------------|-------|
| `Image filename` | Source data file path | - |
| `Event` | Event identifier within file | - |
| `Image serial number` | Sequential frame number | integer |
| `hit` | Whether frame is a hit | 0 or 1 |
| `indexed_by` | Indexing method that succeeded | string |
| `n_indexing_tries` | Number of indexing attempts | integer |
| `photon_energy_eV` | X-ray beam energy | eV |
| `beam_divergence` | Beam divergence | radians |
| `beam_bandwidth` | Relative bandwidth | fraction |
| `average_camera_length` | Detector distance | meters |

### Peak List

```
Peaks from peak search
  fs/px   ss/px (1/d)/nm^-1   Intensity  Panel
  234.50  567.80      0.1234    1500.00  p0a0
  ...
End of peak list
```

| Column | Description | Units |
|--------|-------------|-------|
| `fs/px` | Fast-scan coordinate | pixels |
| `ss/px` | Slow-scan coordinate | pixels |
| `(1/d)/nm^-1` | Resolution (1/d-spacing) | nm⁻¹ |
| `Intensity` | Peak intensity | arbitrary |
| `Panel` | Detector panel name | string |

### Crystal Data

Each chunk may contain zero or more crystals:

```
--- Begin crystal
Cell parameters 5.43000 5.43000 5.43000 nm, 90.00000 90.00000 90.00000 deg
astar = +0.1234567 +0.0000000 +0.0000000 nm^-1
bstar = +0.0000000 +0.1234567 +0.0000000 nm^-1
cstar = +0.0000000 +0.0000000 +0.1234567 nm^-1
lattice_type = cubic
centering = F
unique_axis = *
profile_radius = 0.005000 nm^-1
diffraction_resolution_limit = 0.200000 nm^-1 or 5.00 A
num_reflections = 1234
num_saturated_reflections = 5
num_implausible_reflections = 2
predict_refine/det_shift x = 0.001234 y = -0.000567 mm
Reflections measured after indexing
   h    k    l          I   sigma(I)       peak background  fs/px  ss/px panel
   1    0    0     1234.56      45.67    1200.00      50.00 234.50 567.80 p0a0
   ...
End of reflections
--- End crystal
```

#### Crystal Metadata

| Field | Description | Units |
|-------|-------------|-------|
| `Cell parameters` | a, b, c, alpha, beta, gamma | nm, degrees |
| `astar`, `bstar`, `cstar` | Reciprocal lattice vectors | nm⁻¹ |
| `lattice_type` | Bravais lattice type | triclinic/monoclinic/orthorhombic/tetragonal/rhombohedral/hexagonal/cubic |
| `centering` | Lattice centering | P/C/I/F/R |
| `unique_axis` | Unique axis for monoclinic | a/b/c/* |
| `profile_radius` | Integration profile radius | nm⁻¹ |
| `diffraction_resolution_limit` | Resolution limit | nm⁻¹ or Angstrom |
| `num_reflections` | Total reflections | integer |
| `num_saturated_reflections` | Saturated count | integer |
| `num_implausible_reflections` | Implausible count | integer |
| `predict_refine/det_shift` | Detector shift refinement | mm |

#### Reflection List

| Column | Description | Units |
|--------|-------------|-------|
| `h`, `k`, `l` | Miller indices | integers |
| `I` | Integrated intensity | arbitrary |
| `sigma(I)` | Intensity uncertainty | arbitrary |
| `peak` | Peak intensity | arbitrary |
| `background` | Mean background | arbitrary |
| `fs/px` | Fast-scan coordinate | pixels |
| `ss/px` | Slow-scan coordinate | pixels |
| `panel` | Detector panel name | string |

## Units Conversion Reference

| Quantity | Stream File | SI Units | Conversion |
|----------|-------------|----------|------------|
| Cell lengths | nm | m | multiply by 1e-9 |
| Cell angles | degrees | radians | multiply by π/180 |
| Reciprocal vectors | nm⁻¹ | m⁻¹ | multiply by 1e9 |
| Resolution | nm⁻¹ | m⁻¹ | multiply by 1e9 |
| Wavelength | (from eV) | m | λ = hc/(e × E_eV) |
| Detector shift | mm | m | multiply by 1e-3 |

## Reading Flags

CrystFEL uses flags to control selective reading:

| Flag | Value | Purpose |
|------|-------|---------|
| `STREAM_REFLECTIONS` | 2 | Read/write integrated reflections |
| `STREAM_PEAKS` | 4 | Read/write peak search results |
| `STREAM_DATA_DETGEOM` | 8 | Reconstruct detector geometry |

## Python Implementation Guide

### Recommended Data Classes

```python
from dataclasses import dataclass, field
from typing import List, Optional, Tuple

@dataclass
class Peak:
    fs: float              # fast-scan coordinate (pixels)
    ss: float              # slow-scan coordinate (pixels)
    resolution: float      # 1/d (nm^-1)
    intensity: float
    panel: str

@dataclass
class Reflection:
    h: int
    k: int
    l: int
    intensity: float
    sigma: float
    peak: float
    background: float
    fs: float
    ss: float
    panel: str

@dataclass
class UnitCell:
    a: float = 0.0           # nm
    b: float = 0.0           # nm
    c: float = 0.0           # nm
    alpha: float = 0.0       # degrees
    beta: float = 0.0        # degrees
    gamma: float = 0.0       # degrees
    lattice_type: str = ""
    centering: str = ""
    unique_axis: str = ""

@dataclass
class Crystal:
    cell: UnitCell = field(default_factory=UnitCell)
    astar: Tuple[float, float, float] = (0.0, 0.0, 0.0)  # nm^-1
    bstar: Tuple[float, float, float] = (0.0, 0.0, 0.0)  # nm^-1
    cstar: Tuple[float, float, float] = (0.0, 0.0, 0.0)  # nm^-1
    profile_radius: float = 0.0        # nm^-1
    resolution_limit: float = 0.0      # nm^-1
    num_reflections: int = 0
    num_saturated: int = 0
    num_implausible: int = 0
    det_shift_x: float = 0.0           # mm
    det_shift_y: float = 0.0           # mm
    reflections: List[Reflection] = field(default_factory=list)
    # Note: In stream_parser.py, reflections use lazy parsing for performance

@dataclass
class Chunk:
    filename: str = ""
    event: str = ""
    serial: int = 0
    hit: bool = False
    indexed_by: str = ""
    n_indexing_tries: int = 0
    photon_energy_eV: float = 0.0
    beam_divergence: float = 0.0       # radians
    beam_bandwidth: float = 0.0        # fraction
    average_camera_length: float = 0.0 # m
    num_peaks: int = 0
    peak_resolution: float = 0.0       # nm^-1
    peaks: List[Peak] = field(default_factory=list)
    crystals: List[Crystal] = field(default_factory=list)

@dataclass
class StreamFile:
    """Container for parsed chunks.

    Note: The current stream_parser.py implementation focuses on chunk parsing
    and does not parse header sections (geometry file, target unit cell, version).
    """
    chunks: List[Chunk] = field(default_factory=list)
```

### API Usage

```python
from stream_parser import iter_chunks, parse_stream

# Memory-efficient iteration (recommended for large files)
for chunk in iter_chunks('file.stream'):
    print(chunk.filename, chunk.serial)

# Load all chunks into memory (for smaller files)
stream = parse_stream('file.stream')
print(f"Parsed {len(stream.chunks)} chunks")

# Fast stats-only mode (skip reflection parsing)
for chunk in iter_chunks('data.stream', load_reflections=False):
    print(f"Crystals: {len(chunk.crystals)}")
```

### Key Parsing Patterns

```python
import re

# Version line
version_match = re.match(r'CrystFEL stream format (\d+\.\d+)', line)

# Key-value with colon
if line.startswith('Image filename: '):
    filename = line[16:].strip()

# Key-value with equals
if line.startswith('hit = '):
    hit = int(line[6:].strip()) == 1

# Cell parameters line
cell_match = re.match(
    r'Cell parameters ([\d.]+) ([\d.]+) ([\d.]+) nm, '
    r'([\d.]+) ([\d.]+) ([\d.]+) deg',
    line
)

# Reciprocal vector line
astar_match = re.match(
    r'astar = ([+-]?[\d.]+) ([+-]?[\d.]+) ([+-]?[\d.]+) nm\^-1',
    line
)

# Peak/reflection data lines: split by whitespace
parts = line.split()
```

## Test Data

Sample stream file for testing:
```
/sdf/data/lcls/ds/mfx/mfxl1025422/results/btx/streams/ox112it2.stream  # roughly 40GB in size
/sdf/data/lcls/ds/cxi/cxil1015922/results/Quentin/b2/day3_4/stream_r0136/full.stream  $ roughly 5GB in size
```

Runtime performance should be measured by "lines per second".  Chunk per second
isn't really good, because chunk size (measured by the number of lines in the
chunk) isn't uniform across stream files.

## References

- Source: `externals/crystfel/libcrystfel/src/stream.c`
- Header: `externals/crystfel/libcrystfel/src/stream.h`
- CrystFEL documentation: https://www.desy.de/~twhite/crystfel/
